#' Random number generation for Correlated Survival and Ordinal Outcomes
#'
#' This function generates random number vectors of correlated survival and
#' ordinal outcomes. Gaussian or Clayton copula is used to specify the
#' correlation structure. Marginal distributions are based on a exponential
#' distribution. The order outcome is generated by discretizing one of the
#' correlated random numbers based on the quantile.
#'
#' @param target_tau the target value of the Kendall's \eqn{\tau}
#' @param num_samples the number of simulation samples
#' @param censoring_rate the censoring rate
#' @param copula_type copula type (default = "Gaussian")
#' \itemize{
#' \item \code{Gaussian}: Gaussian copula
#' \item \code{Clayton}: Clayton copula
#' }
#' @param x_levels the number of category for the ordinal outcome (default = 5)
#' @param x_probs the proportion of each level of x (default = "equal")
#' \itemize{
#' \item \code{equal}: equal sample sizes
#' \item \code{random}: random sample sizes
#' }
#' @param x_values the cutoff values of x. If \code{x_values} is specified,
#'                 \code{x_probs} is ignored. \code{x_levels - 1} and the
#'                 lengths of \code{x_levels} must be equal.
#' @param hr the hazard rate for survival time (default = 1.0)
#' @return
#' \itemize{
#' \item \code{y}: the survival time or censoring time outcome vector
#' \item \code{event}: the event indicator outcome vector
#' \item \code{x}: the ordinal (or continuous) outcome vector
#' \item \code{t}: the true survival time vector (for simulation)
#' \item \code{c}: the true censoring time vector (for simulation)
#' \item \code{x0}: \code{x} before discretization (for simulation)
#' }
#' @examples
#' library(surrosurvo)
#' set.seed(1234)
#' data <- generate_rv(0.7, 500, 0.3)
#' surrosurvo(data$y, data$event, data$x)
#'
#' # 5-level ordinal variable with Clayton copula
#' data <- generate_rv(0.7, 500, 0.1, copula_type = "Clayton", x_levels = 5)
#' surrosurvo(data$y, data$event, data$x)
#' @importFrom copula normalCopula claytonCopula rCopula
#' @importFrom stats qexp quantile rexp runif
#' @export
generate_rv <- function(target_tau, num_samples, censoring_rate,
                        copula_type = c("Gaussian", "Clayton"),
                        x_levels = 5, x_probs = c("equal", "random"),
                        x_values = NULL, hr = 1) {

  # initial check
  util_check_inrange(target_tau, -1.0, 1.0)
  util_check_gt(num_samples, 1)
  util_check_inrange(censoring_rate, 0, 1.0)
  util_check_ge(x_levels, 1)
  util_check_gt(hr, 0)
  lstc <- c("Gaussian", "Clayton")
  copula_type <- match.arg(copula_type)
  if (!is.element(copula_type, lstc)) {
    stop("Unknown 'copula_type' specified.")
  }
  lstx <- c("equal", "random")
  x_probs <- match.arg(x_probs)
  if (!is.element(x_probs, lstx)) {
    stop("Unknown 'x_probs' specified.")
  }
  if (!is.null(x_values) & (x_levels != length(x_values) + 1)) {
    stop("'x_levels - 1' and the lengths of 'x_levels' must be equal.")
  }

  # generate random number vectors
  if (copula_type == "Gaussian") {
    cop <- normalCopula(param = sin(target_tau * pi / 2), dim = 2)
  } else if (copula_type == "Clayton") {
    cop <- claytonCopula(param = 2 * target_tau / (1 - target_tau), dim = 2)
  }

  hrc <- (censoring_rate * hr) / (1 - censoring_rate)

  u <- rCopula(num_samples, cop)
  t <- qexp(u[, 1])/hr
  c <- rexp(num_samples)/hrc
  y <- pmin(t, c)
  event <- ifelse(y == t, 1, 0)

  # discritizing
  if (!is.null(x_values)) {
    x <- u[, 2]
    for (j in 1:x_levels) {
      if (j == 1) {
        x[u[, 2] < x_values[1]] <- j - 1
      } else if (j == x_levels) {
        x[u[, 2] >= x_values[j - 1]] <- j - 1
      } else {
        x[u[, 2] >= x_values[j - 1] & u[, 2] < x_values[j]] <- j - 1
      }
    }
  } else {
    if (x_probs == "equal") {
      x_probs <- seq(0, 1, length.out = x_levels + 1)
    } else if (x_probs == "random") {
      x_probs <- c(0, runif(x_levels - 1), 1)
      x_probs <- x_probs[order(x_probs)]
    }
    quantiles <- quantile(u[, 2], probs = x_probs)
    x <- cut(u[, 2], breaks = quantiles, labels = 0:(x_levels - 1), include.lowest = TRUE)
    x <- as.numeric(x) - 1
  }
  x0 <- u[, 2]

  # output
  data.frame(y, event, x, t, c, x0)

}
